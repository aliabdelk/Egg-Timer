```verilog
`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Module: debounce
//////////////////////////////////////////////////////////////////////////////////

module debounce(
    input clk,
    input press,
    input count_db,
    output reg press_db
    );
    
    reg q1;
    reg [23:0] counter_high;
    reg [23:0] counter_low;
    wire clk_2hz;
    
    always @ (posedge clk) 
     begin
        q1<=press;
        if ((counter_high == count_db) | (counter_low == count_db))
         begin
            press_db <= q1;
            counter_high <= 0;
            counter_low <= 0;
         end
        else if (press) counter_high <= counter_high + 1;
        else counter_low <= counter_low + 1;
        
     end
    
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: blinker_on
//////////////////////////////////////////////////////////////////////////////////

module blinker_on(
    input clk,
    input enable,
    input reset,
    output reg blinker_on
    );
    always @ (posedge clk or posedge reset)
     begin
        if (reset) blinker_on <= 0;
        else if (enable) blinker_on <= ~blinker_on;
        else blinker_on <= 0;
     end
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: pulse
//////////////////////////////////////////////////////////////////////////////////

module pulse(
    input clk,
    input button,
    input set_time,
    input reset,
    output reg pulse
    );
    always @(posedge clk or posedge reset)
     begin
        if (reset) pulse <= 0;
        else if (set_time) pulse <= 0;
        else if (button) pulse <= ~pulse;
        else pulse <= pulse;

     end
    
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: clock_divider
//////////////////////////////////////////////////////////////////////////////////

module clock_divider(
    input clk_in,
    input rst,
    input en, 
    input half_period,
    output reg clk_out
    );
    reg [23:0] counter;
    
    always @ (posedge clk_in or posedge rst)
        begin
            if (rst)
                begin
                    clk_out <= 0;
                    counter <= 0;
                end
            else
                begin
                    counter <= counter + 1;
                    if (counter == half_period)
                        begin
                            counter <= 0;
                            clk_out <= ~clk_out;
                        end
                end
        end
    
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: cooktime
//////////////////////////////////////////////////////////////////////////////////

module cooktime(
    input clk,//clk
    input enable,//set time button
    input enableSW, //Enable switch
    input rst,//reset
    input seconds, //Seconds button pulse
    input minutes, //Minutes button pulse
    output reg [3:0] sec_out1,
    output reg [3:0] sec_out2,
    output reg [3:0] min_out1,
    output reg [3:0] min_out2 
    );
    always @(posedge clk or posedge rst)//enable or seconds or minutes
            begin
               if (rst) 
                begin//syncrhonous reset
                    sec_out1 <= 0;
                    sec_out2 <= 0;
                    min_out1 <= 0;
                    min_out2 <= 0;
                end
                
               else if (enable) 
                begin
                    //Max time is 60 minutes
                    if (min_out2 == 6) 
                     begin
                        min_out2 = min_out2;
                        min_out1 <= 0;
                        sec_out2 <= 0;
                        sec_out1 <= 0;                                            
                     end
                    //Increase seconds
                    else if (seconds)
                        begin                      
                            //Carry over if first digit seconds max
                           
                           if (sec_out1 == 9)
                                begin
                                    sec_out1 <= 0;
                                    //Increase minutes when 60 seconds is hit
                                    if (sec_out2 == 5)
                                        begin
                                            sec_out2 <= 0;
                                            //Check minute digit 1
                                            if (min_out1 == 9)
                                                begin
                                                    min_out1 = 0;
                                                    min_out2 <= min_out2 + 1;
                                                end
                                            else min_out1 <= min_out1 + 1;
                                        end                                
                                    else sec_out2 <= sec_out2 + 1;
                                end
                             else sec_out1 <= sec_out1 + 1;  
                         end
                         
                    else if (minutes)
                        begin
                            if (min_out1 == 9)
                                 begin
                                     min_out1 = 0;
                                     min_out2 <= min_out2 + 1;
                                 end
                             else min_out1 <= min_out1 +1;
                         end
                    else
                        begin
                            sec_out1 <= sec_out1;
                            sec_out2 <= sec_out2;
                            min_out1 <= min_out1;
                            min_out2 <= min_out2;
                        end
                end
               else
                begin
                 sec_out1 <= sec_out1;
                 sec_out2 <= sec_out2;
                 min_out1 <= min_out1;
                 min_out2 <= min_out2;
                end
            end//Always end
        
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: countime
//////////////////////////////////////////////////////////////////////////////////

module countime(
    input [3:0] sec_in1, //load value inputs
    input [3:0] min_in1,
    input [3:0] sec_in2,
    input [3:0] min_in2,
    //input clk,
    input clk_1hz,
    input enable,//enable
    input start_pulse,//start pulse
    input set_time,//load active
    input rst,//reset
    output reg [3:0] sec_out1,//segment ouputs
    output reg [3:0] min_out1,
    output reg [3:0] sec_out2,
    output reg [3:0] min_out2,
    output reg counting
    );

always @ (posedge rst or posedge rst, posedge clk_1hz)begin //posedge clk or or posedge start_pulse
    if (rst) begin//async reset
        counting <= 0;
        sec_out1 <= 0;
        sec_out2 <= 0;
        min_out1 <= 0;
        min_out2 <= 0;
        
    end else if(set_time)begin//if load is active, we load output registers with input values
        counting <= 0;
        sec_out1 <= sec_in1;
        sec_out2 <= sec_in2;
        min_out1 <= min_in1;
        min_out2 <= min_in2;
        
    end else if (min_out2 == 0 && min_out1 == 0 && sec_out2 == 0 && sec_out1 ==0) begin
        counting <= 0;
        sec_out1 <= 0;
        sec_out2 <= 0;
        min_out1 <= 0;
        min_out2 <= 0;
        
    end else if(enable && start_pulse && clk_1hz)begin //else we countdown until 0
        counting <= 1;
        sec_out1 <= sec_out1 - 1;
        if (sec_out1 < 1) begin
            sec_out2 <= sec_out

2 - 1;
            sec_out1 <= 9;
            if (sec_out2 < 1) begin
                min_out1 <= min_out1 - 1;
                sec_out2 <= 5;
                if (min_out1 < 1) begin
                    min_out2 <= min_out2 - 1;
                    min_out1 <= 9;
                    if (min_out2 < 1) begin
                        min_out2 <= 0;
                    end
                end 
            end
        end
    end 

end    
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: set_display_digits
//////////////////////////////////////////////////////////////////////////////////

module set_display_digits(
    input clk,
    input enable,
    input start_pulse,
    
    //Cook time digits
    input [3:0] sec1,
    input [3:0] sec2,
    input [3:0] min1,
    input [3:0] min2,
        
    //Count time 7 Seg digits
    input [3:0] sec_out1,
    input [3:0] sec_out2,
    input [3:0] min_out1,
    input [3:0] min_out2,
    
    output reg [3:0] s1,
    output reg [3:0] s2,
    output reg [3:0] m1,
    output reg [3:0] m2 
    );
    
    always @(posedge clk)
     begin
        if (enable && start_pulse)
         begin
            s1 <= sec_out1;
            s2 <= sec_out2;
            m1 <= min_out1;
            m2 <= min_out2;
         end
        else
         begin
            s1 <= sec1;
            s2 <= sec2;
            m1 <= min1;
            m2 <= min2;
         end
     end
    
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: display
//////////////////////////////////////////////////////////////////////////////////

module display(
    input clk,
    input rst,
    input [3:0] sec_1,
    input [3:0] sec_2,
    input [3:0] min_1,
    input [3:0] min_2,
    output reg [6:0] seg,
    output reg [7:0] an,
    output reg decimal
    );
    
    //BCD
    wire [6:0] seg1, seg2, seg3, seg4;
    bcd7seg bcd1(.x(sec_1), .seg(seg1));
    bcd7seg bcd2(.x(sec_2), .seg(seg2));
    bcd7seg bcd3(.x(min_1), .seg(seg3));
    bcd7seg bcd4(.x(min_2), .seg(seg4));
    
    reg [3:0] count;
    always @(posedge clk or posedge rst) 
        begin
          if (rst) begin
              decimal = 1;
              count <= 3'b000;
              an <= 8'b11111111;
          end 
          else
           begin
              case(count)
                  3'b000:
                      begin
                          seg <= seg1;
                          an <= 8'b11111110;
                          count <= count + 1;
                      end
                  3'b01:
                      begin
                          an <= 8'b11111111;
                          count <= count + 1;
                      end
                  3'b010:
                      begin
                        seg <= seg2;
                        an <= 8'b11111101;
                        count <= count + 1;
                      end
                      
                  3'b011:
                    begin
                        an <= 8'b11111111;
                        count <= count + 1;
                    end
                  3'b100:
                     begin
                        seg <= seg3;
                        decimal = 0;
                        an <= 8'b11111011;
                        count <= count + 1;
                     end
                     
                   3'b101:
                    begin
                     decimal = 1;
                     an <= 8'b11111111;
                     count <= count + 1;
                    end
                   3'b110:
                      begin
                        seg <= seg4;
                        an <= 8'b11110111;
                        count <= count + 1;
                      end
                      
                   3'b111:
                       begin
                           an <= 8'b11111111;
                           count <= 3'b000;
                       end
                   default:
                       begin
                           count <= 3'b000;
                       end
                endcase
            end
        end 
endmodule

//////////////////////////////////////////////////////////////////////////////////
// Module: top
//////////////////////////////////////////////////////////////////////////////////

module top(
    input count_en,
    input rst,
    input clk, //100MHz clk
    input min, //BTNU
    input sec, //BTND
    input set_time, //BTNL set time
    input start, //BTNR start timer
    output enabled, //LED turns on when count_en(SW0) is on 
    output blinker, // LED that blinks (1 sec on 1 sec off)
    output sec_led,
    output min_led,
    output set_time_led,
    output start_led,
    output rst_led,
    output decimal,
    output [7:0] an, // anode for 7 segment displays
    output [6:0] seg // 7 segment output
    );
    
    //Clk wires
    wire clk_5mhz, clk_1hz, clk_min, clk_500hz, clk_2hz, clk_100hz;
    
    //Button wires
    wire sec_button;
    wire min_button;
    wire start_button;
    
    //Cook time 7 Seg digits
    wire [3:0] sec1;
    wire [3:0] sec2;
    wire [3:0] min1;
    wire [3:0] min2;
    
    //Count time 7 Seg digits
    wire [3:0] sec_out1;
    wire [3:0] sec_out2;
    wire [3:0] min_out1;
    wire [3:0] min_out2;
    
    //7 Seg display digits
    wire [3:0] s1;
    wire [3:0] s2;
    wire [3:0] m1;
    wire [3:0] m2;
    
    //Start pulse
    wire start_pulse;

    //Done count down
    wire counting;
    
    //Instatiate clocks
    clk_wiz_0 base_clk (.clk_out1(clk_5mhz),.clk_in1(clk));
   
    clk_div_5mhzto1hz div1(.clk_in(clk_5mhz),.rst(rst),.en(1),.clk_out(clk_1hz));
    clk_div_5mhzto500hz div2(.clk_in(clk_5mhz),.rst(rst),.en(1),.clk_out(clk_500hz));
    clk_div_5mhzto100hz div3(.clk_in(clk_5mhz),.rst(rst),.en(1),.clk_out(clk_100hz));
    
    //Debounce buttons
    debounce start_button_db (.clk

(clk_5mhz), .press(start), .press_db(start_button), .count_db(24'd1_000_000));
    debounce set_button_db (.clk(clk_5mhz), .press(set_time), .press_db(set_button), .count_db(24'd1_000_000));
    debounce seconds_button_db (.clk(clk_5mhz), .press(sec), .press_db(sec_button), .count_db(24'd1_000_000));
    debounce minutes_button_db (.clk(clk_5mhz), .press(min), .press_db(min_button), .count_db(24'd1_000_000));
    
    //Assign values
    assign enabled = count_en;
    assign sec_led = sec_button;
    assign min_led = min_button;
    assign set_time_led = set_button;
    assign start_led = start_pulse;
    assign rst_led = rst;
    
    //blinker
    blinker_on led_blinker(.clk(clk_1hz), .enable(counting), .reset(rst), .blinker_on(blinker));
    
    //Pulse start button
    pulse startButton (.clk(clk_5mhz), .button(start_button), .set_time(set_button), .reset(rst), .pulse(start_pulse));
    
    //Cook time module
    cooktime timer (.clk(clk_100hz), 
                    .enable(set_button), .enableSW(count_en), .rst(rst), 
                    .seconds(sec_button), .minutes(min_button), 
                    .sec_out1(sec1), .sec_out2(sec2),
                    .min_out1(min1), .min_out2(min2)                  
                    );
                    
    //Count time
    countime count_time1 (
                       .clk_1hz(clk_1hz), .enable(count_en), .rst(rst), .set_time(set_button), .start_pulse(start_pulse),
                           
                       .sec_in1(sec1), .sec_in2(sec2),
                       .min_in1(min1), .min_in2(min2),
                      
                       .sec_out1(sec_out1), .sec_out2(sec_out2),
                       .min_out1(min_out1), .min_out2(min_out2),
                       
                       .counting(counting)
                        );   
    
   //Display if statment
   set_display_digits digits1 (
                               .clk(clk_5mhz), .enable(count_en), .start_pulse(start_pulse),
                               
                               //Cook time digits
                               .sec1(sec1),.sec2(sec2),
                               .min1(min1), .min2(min2),
                                   
                               //Count time 7 Seg digits
                               .sec_out1(sec_out1), .sec_out2(sec_out2),
                               .min_out1(min_out1), .min_out2(min_out2),
                               
                               //Display digits
                               .s1(s1), .s2(s2),
                               .m1(m1), .m2(m2) 
                               );
                                     
    //Display on 7 seg
    display display7_seg (
                        .clk(clk_500hz), .rst(rst),
                        //Time
                        .sec_1(s1), .sec_2(s2),
                        .min_1(m1), .min_2(m2),
                        .seg(seg), .an(an), .decimal(decimal)//display
                        );
    
endmodule
```
